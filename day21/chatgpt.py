
# Solution generated by chatgpt.

from collections import deque

# Define the numpad as a grid

'''
NUMPAD = {
    0: (3, 1),
    1: (0, 0), 2: (0, 1), 3: (0, 2),
    4: (1, 0), 5: (1, 1), 6: (1, 2),
    7: (2, 0), 8: (2, 1), 9: (2, 2), 
}
'''

NUMPAD = {
    0: (1, 3),
    1: (0, 2), 2: (1, 2), 3: (2, 2),
    4: (0, 1), 5: (1, 1), 6: (2, 1),
    7: (0, 0), 8: (1, 0), 9: (2, 0), "enter": (2, 3)
}


# Possible moves and their offsets
MOVES = {
    "^": (0, -1),
    "v": (0, 1),
    "<": (-1, 0),
    ">": (1, 0),
    "A": (0, 0)
}

# Reverse lookup for moves
MOVE_KEYS = {v: k for k, v in MOVES.items()}


def shortest_path(start, target):
    """
    Calculate the shortest path on the numpad between two keys.
    Returns a list of moves (up, down, left, right, enter).
    """
    start_pos = NUMPAD[start]
    target_pos = NUMPAD[target]
    
    queue = deque([(start_pos, [])])
    visited = set()
    
    while queue:
        current_pos, path = queue.popleft()

        if current_pos == target_pos:
            return path + ["enter"]

        if current_pos in visited:
            continue

        visited.add(current_pos)

        for move, offset in MOVES.items():
            if move == "enter":
                continue

            new_pos = (current_pos[0] + offset[0], current_pos[1] + offset[1])

            if new_pos in NUMPAD.values():
                queue.append((new_pos, path + [move]))

    return []


def translate_to_robot_actions(path):
    """
    Translate a path of numpad moves into actions for a robot to press those keys.
    """
    robot_actions = []
    current_pos = (2, 2)  # Assume the robot starts centered on its arrow keys

    for move in path:
        target_pos = (current_pos[0] + MOVES[move][0], current_pos[1] + MOVES[move][1])
        if target_pos != current_pos:
            robot_actions.append(MOVE_KEYS[(target_pos[0] - current_pos[0], target_pos[1] - current_pos[1])])
        robot_actions.append("enter")
        current_pos = target_pos

    return robot_actions


def solve_multilevel_numpad(sequence):
    """
    Given a sequence of digits, determine the shortest sequence of actions
    for the outermost robot to type them.
    """
    outer_robot_actions = []
    current_numpad_pos = 5  # Assume the numpad starts at '5'

    for digit in sequence:
        # Step 1: Calculate shortest path on the numpad
        numpad_path = shortest_path(current_numpad_pos, digit)
        current_numpad_pos = digit

        # Step 2: Translate the numpad path into actions for the robot
        robot_actions = translate_to_robot_actions(numpad_path)

        # Step 3: Add these actions to the outermost robot actions
        outer_robot_actions.extend(robot_actions)

    return outer_robot_actions


# Example Usage
if __name__ == "__main__":
    sequence = [0, 2, 9, "enter"]  # Example sequence to type ("029A")
    actions = solve_multilevel_numpad(sequence)
    print("Actions for the outermost robot:", actions)



